<?php
// $Id$


/**
 * @file
 * recipe.module - share recipes
 */

/**
 * Implementation of hook_perm().
 */
function recipe_perm() {
  // register permissions. TODO: probably need individual types for each import/export -> "might be too many-jv").
  return array(t('create recipes'), t('edit own recipes'), t('edit any recipes'), t('export recipes'));
}

/**
 * Implementation of hook_load().
 */
function recipe_load($node) {
  $recipe = db_fetch_object(db_query("SELECT * FROM {recipe} WHERE nid = %d", $node->nid));
  $recipe->ingredients = recipe_load_ingredients($node);
  return $recipe;
}

/**
 * Implementation of hook_link().
 */
function recipe_link($type, $node = NULL, $teaser = FALSE) {
  $links = array();

  if ($type == 'node' && $node->type == 'recipe') {
    if (!$teaser) {
      if ( user_access('export recipes') ) {
        $formats = module_invoke_all('recipeio', 'export_single');
        foreach ( $formats as $key => $format ) {
          $links[$key] = array(
            'title' => t('Export to '). $format['format_name'],
            'href' => "recipe/export/$key/$node->nid/$node->yield",
            'attributes' => array('title' => $format['format_help']),
          );
        }
      }
    }
  }

  return $links;
}

/**
 * Implementation of hook_node_info().
 */
function recipe_node_info() {
  return array(
    'recipe' => array(
      'name' => t('Recipe'),
      'module' => 'recipe',
      'description' => t('Share your favorite recipes with your fellow cooks.'),
    )
  );
}

/**
 * Implementation of hook_help().
 */
function recipe_help($path, $arg) {
  switch ($path) {
    case 'node/add/recipe':
      return variable_get('recipe_help', '');
  }
}

/**
 * Implementation of hook_insert().
 *
 * As a new node is being inserted into the database, we need to do our own
 * database inserts.
 */
function recipe_insert($node) {
  db_query("INSERT INTO {recipe} (nid, source, yield, notes, instructions, preptime) VALUES (%d, '%s', '%s', '%s', '%s', %d)", $node->nid, $node->source, $node->yield, $node->notes, $node->instructions, $node->preptime);
  recipe_save_ingredients($node);
}

/**
 * Implementation of hook_update().
 *
 * As an existing node is being updated in the database, we need to do our own
 * database updates.
 */
function recipe_update($node) {
  db_query("UPDATE {recipe} SET source = '%s', yield = %d, notes = '%s', instructions = '%s', preptime = %d WHERE nid = %d", $node->source, $node->yield, $node->notes, $node->instructions, $node->preptime, $node->nid);
  if (!db_affected_rows()) {
    recipe_insert($node);
    return;
  }
  recipe_save_ingredients($node);
}

/**
 * Implementation of hook_delete().
 *
 * When a node is deleted, we need to clean up related tables.
 */
function recipe_delete($node) {
  db_query("DELETE FROM {recipe} WHERE nid = %d", $node->nid);
  db_query("DELETE FROM {recipe_node_ingredient} WHERE nid = %d", $node->nid);
}

/**
* Implementation of hook_form().
*/
function recipe_form(&$node, $form_state) {

  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => t('Title'),
    '#size' => 60,
    '#maxlength' => 128,
    '#required' => TRUE,
    '#default_value' => $node->title,
  );

  // Now we define the form elements specific to our node type.
  $form['body'] = array(
    '#type' => 'textarea',
    '#title' => t('Description'),
    '#default_value' => $node->body,
    '#cols' => 60,
    '#rows' => 2,
    '#description' => t('A short description or "teaser" for the recipe.'),
    '#required' => TRUE,
  );
  $form['yield'] = array(
    '#type' => 'textfield',
    '#title' => t('Yield'),
    '#default_value' => $node->yield,
    '#size' => 10,
    '#maxlength' => 10,
    '#description' => t('The number of servings the recipe will make.'),
    '#attributes' => NULL,
    '#required' => TRUE,
  );
  $form['preptime'] = array(
    '#type' => 'select',
    '#title' => t('Preparation time'),
    '#default_value' => $node->preptime,
    '#options' => array(
      5 => t('5 minutes'),
      10 => t('10 minutes'),
      15 => t('15 minutes'),
      20 => t('20 minutes'),
      30 => t('30 minutes'),
      45 => t('45 minutes'),
      60 => t('1 hour'),
      90 => t('1 1/2 hours'),
      120 => t('2 hours'),
      150 => t('2 1/2 hours'),
      180 => t('3 hours'),
      210 => t('3 1/2 hours'),
      240 => t('4 hours'),
      300 => t('5 hours'),
      360 => t('6 hours'),
    ),
    '#description' => t('How long does this recipe take to prepare (i.e. elapsed time)'),
  );
  $form["source"] = array(
    '#type' => 'textfield',
    '#title' => t('Source'),
    '#default_value' => $node->source,
    '#size' => 60,
    '#maxlength' => 127,
    '#description' => t('Optional. Does anyone else deserve credit for this recipe?'),
  );

  // Table of existing ingredients
  $form['ingredients']['#tree'] = TRUE;
  $system = variable_get('recipe_ingredient_system', 'complex');
  if ($system == 'complex') {
    $form['ingredients']['headings'] = array(
      '#value' => '<div><table ><thead><tr><th>'. t('Quantity') .'</th><th>'.
                  t('Units') .'</th><th>'. t('Ingredient name') .
                  '</th></tr></thead>'."\n".'<tbody>',
    );
  }
  else {
    $form['ingredients']['headings'] = array(
      '#value' => '<div><table ><thead><tr><th>'. t('Ingredients') .'</th></tr></thead>'."\n".'<tbody>',
    );
  }
  $rows = array();
  $callback = 'recipe/ingredient/autocomplete';
  $num_ingredients = 0;
  if ($node->ingredients) {
    foreach ($node->ingredients as $id => $ingredient) {
      $num_ingredients = $id+1;
      if ($id == 0) {
        $j = '0';
      }
      else {
        $j = $id;
      }

      // For preview, node->ingredients is an array, for actual display, it's an object
      $name = '';
      $unit_id = '';
      $abbreviation = '';
      $quantity = 0;
      if (is_array($ingredient)) {
        $name = $ingredient['name'];
        $unit_id = $ingredient['unit_id'];
        $abbreviation = $ingredient['abbreviation'];
        $quantity = $ingredient['quantity'];
      }
      else {
        $name = $ingredient->name;
        $unit_id = $ingredient->unit_id;
        $abbreviation = $ingredient->abbreviation;
        $quantity = $ingredient->quantity;
      }

      if ($name && isset($quantity)) {
        // When can the following statement be true?
        if (!$ingredient) {
          drupal_set_message(t('Recipe module: An error has occurred. Please report this error to the system administrator.'), 'error');
          if (is_array($ingredient)) {
            $ingredient['quantity'] = '';
            $ingredient['unit_id'] = 21;
            $ingredient['name'] = '';
          }
          else {
            $ingredient->quantity = '';
            $ingredient->unit_id = 21;
            $ingredient->name = '';
          }
        }
        if ($system == 'complex') {
          $form['ingredients'][$j]['open_tags'] = array(
            '#value' => '<tr><th>',
          );
          $form['ingredients'][$j]['quantity'] = array(
            '#type' => 'textfield',
            '#title' => '',
            '#default_value' => preg_replace('/\&frasl;/', '/', recipe_ingredient_quantity_from_decimal($quantity)),
            '#size' => 8,
            '#maxlength' => 8,
          );
          $form['ingredients'][$j]['mid1_tags'] = array(
            '#value' => '</th><th>',
          );
          $form['ingredients'][$j]['unit_id'] = array(
            '#type' => 'select',
            '#title' => '',
            '#default_value' => $unit_id,
            '#options' => recipe_unit_options(),
          );
          $form['ingredients'][$j]['mid2_tags'] = array(
            '#value' => '</th><th>',
          );
          $form['ingredients'][$j]['name'] = array(
            '#type' => 'textfield',
            '#title' => '',
            '#default_value' => $name,
            '#size' => 64,
            '#maxlength' => 128,
            '#autocomplete_path' => $callback,
          );
          $form['ingredients'][$j]['close_tags'] = array(
            '#value' => '</th></tr>',
          );
        }
        else {
          if ($name) {
            if ($quantity == 0) {
              $quantity = '';
            }
            else {
              $quantity .= ' ';
            }
            if ($abbreviation != '') {
              $abbreviation .= ' ';
            }
            $name = $quantity . $abbreviation . $name;
          }
          $form['ingredients'][$j]['open_tags'] = array(
            '#value' => '<tr><th>',
            '#tree' => TRUE,
          );
          $form['ingredients'][$j]['name'] = array(
            '#type' => 'textfield',
            '#title' => '',
            '#default_value' => $name,
            '#size' => 64,
            '#maxlength' => 128,
            '#autocomplete_path' => $callback,
          );
          $form['ingredients'][$j]['close_tags'] = array(
            '#value' => '</th></tr>',
          );
        } // else
      } // if ($ingredient->name && isset($ingredient->quantity))
    } // foreach ($node->ingredients as $id => $ingredient)
  } // if ($node->ingredients)

  // Add ten more spots for ingredients than are already used
  for ($i = $num_ingredients; $i < $num_ingredients+10; $i++) {
    if ($i == 0) {
      $j = '0';
    }
    else {
      $j = $i;
    }
    if ($system == 'complex') {
      $form['ingredients'][$j]['open_tags'] = array(
        '#value' => '<tr><th>',
      );
      $form['ingredients'][$j]['quantity'] = array(
        '#type' => 'textfield',
        '#title' => '',
        '#size' => 8,
        '#maxlength' => 8,
      );
      $form['ingredients'][$j]['mid1_tags'] = array(
        '#value' => '</th><th>',
      );
      $form['ingredients'][$j]['unit_id'] = array(
        '#type' => 'select',
        '#title' => '',
        '#options' => recipe_unit_options(),
        '#default_value' => 2,
      );
      $form['ingredients'][$j]['mid2_tags'] = array(
        '#value' => '</th><th>',
      );
      $form['ingredients'][$j]['name'] = array(
        '#type' => 'textfield',
        '#title' => '',
        '#size' => 64,
        '#maxlength' => 128,
        '#autocomplete_path' => $callback,
      );
      $form['ingredients'][$j]['close_tags'] = array(
        '#value' => '</th></tr>',
      );
    }
    else {
      $form['ingredients'][$j]['open_tags'] = array(
        '#value' => '<tr><th>',
      );
      $form['ingredients'][$j]['name'] = array(
        '#type' => 'textfield',
        '#title' => '',
        '#size' => 64,
        '#maxlength' => 128,
        '#autocomplete_path' => $callback,
      );
      $form['ingredients'][$j]['close_tags'] = array(
        '#value' => '</th></tr>',
      );
    }
  }
  $form['ingredients']['end'] = array(
    '#value' => '</tbody>' . "\n" . '</table></div>' . "\n",
  );

  $form['instructions'] = array(
    '#type' => 'textarea',
    '#title' => t('Instructions'),
    '#default_value' => $node->instructions,
    '#cols' => 60,
    '#rows' => 10,
    '#description' => t('Step by step instructions on how to prepare and cook the recipe.'),
  );
  $form['notes'] = array(
    '#type' => 'textarea',
    '#title' => t('Additional notes'),
    '#default_value' => $node->notes,
    '#cols' => 60,
    '#rows' => 5,
    '#description' => t('Optional. Describe a great dining experience relating to this recipe, or note which wine or other dishes complement this recipe.'),
  );
  $form['filter'] = filter_form($node->format);

  return $form;
}


/**
 * Implementation of hook_menu().
 *
 * Note: when editing this function you must visit 'admin/menu' to reset the cache
 */
function recipe_menu() {
  $items['node/add/recipe_import'] = array(
    'title' => 'Recipe Import',
    'description' => 'Allows you to create a recipe by pasting various formats into a big text box.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('recipe_import_form'),
    'access callback' => 'recipe_import_access',
    'access arguments' => array('create recipes'),
    'type' => MENU_NORMAL_ITEM
  );

  $items['recipe'] = array(
    'title' => 'Recipes',
    'page callback' => 'recipe_page',
    'access arguments' => array('access content'),
    'type' => MENU_NORMAL_ITEM,
    //'file'  => 'recipe.pages.inc',
  );

  $items['recipe/ingredient/autocomplete'] = array(
    'title' => 'Ingredient autocomplete',
    'page callback' => 'recipe_autocomplete_page',
    'type' => MENU_CALLBACK,
    'access arguments' => array('access content'),
  );

  $items['recipe/export'] = array(
    'page callback' => 'recipe_export',
    'type' => MENU_CALLBACK,
    'access arguments' => array('export recipes'),
  );
  $items['recipe/export_multi'] = array(
    'title' => 'Recipe Export',
    'page callback' => 'recipe_export_multi',
    'access callback' => 'recipe_export_multi_access',
    'access arguments' => array('export recipes'),
    'type' => MENU_NORMAL_ITEM,
    //'file'  => 'recipe.pages.inc',
  );

  $items['admin/settings/recipe'] = array(
    'title' => 'Recipe module',
    'description' => 'Settings that control how the recipe module functions.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('recipe_admin_settings'),
    'access arguments' => array('administer site configuration'),
    'file' => 'recipe.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Implementation of hook_access().
 */
function recipe_access($op, $node, $account) {
  global $user;

  if ($op == 'create') {
    return user_access('create recipes', $account);
  }

  if ($op == 'update' || $op == 'delete') {
    if ( (user_access('edit own recipes', $account) && ($account->uid == $node->uid)) || user_access('edit any recipes', $account)) {
      return TRUE;
    }
  }
}

/**
 * Implementation of hook_block().
 */
function recipe_block($op = 'list', $delta = 0, $edit = array()) {
  // The $op parameter determines what piece of information is being requested.
  switch ($op) {
    case 'list':
      // If $op is "list", we just need to return a list of block descriptions.
      // This is used to provide a list of possible blocks to the administrator,
      // end users will not see these descriptions.
      $blocks[0]['info'] = t('Newest recipes');
      return $blocks;

    case 'view':
      // If $op is "view", then we need to generate the block for display
      // purposes. The $delta parameter tells us which block is being requested.
      switch ($delta) {
        case 0:
          // The subject is displayed at the top of the block. Note that it
          // should be passed through t() for translation.
          $block['subject'] = t('Newest Recipes');
          // The content of the block is typically generated by calling a custom
          // function.
          $result = db_query_range(db_rewrite_sql("SELECT n.nid, n.title, n.uid, u.name FROM {node} n INNER JOIN {node_revisions} r ON n.vid = r.vid INNER JOIN {users} u ON n.uid = u.uid WHERE n.type='recipe' AND n.status =1 ORDER BY n.created DESC"), 0, 5);
          $block["content"] = node_title_list($result);
          break;
      }
      return $block;
  }
}

/**
 * Implementation of hook_view().
 */
function recipe_view($node, $teaser = FALSE, $page = FALSE) {
  if ($page) {
    drupal_set_breadcrumb(array(l(t('Home'), ''), l(t('Recipes'), 'recipe')));
    drupal_add_css(drupal_get_path('module', 'recipe') .'/recipe.css');
  }
  $node = recipe_node_prepare($node, $teaser);

  $node->content['body'] = array(
    '#value' => $teaser ? $node->teaser : theme('recipe_node', $node, $page),
    '#weight' => 1,
  );

  return $node;
}

/**
 * Returns a cached array of recipe unit types
 */
function recipe_unit_options() {
  static $options;
  static $unit_rs;

  if (!isset($unit_rs)) {
    $unit_rs = db_query("SELECT id, type, name, abbreviation FROM {recipe_unit} ORDER BY type ASC, metric");
    $options = array();

    while ($r = db_fetch_object($unit_rs)) {
      if (isset($r->type)) {
        if (!isset($options[$r->type])) {
          $options[$r->type] = array();
        }
        $options[$r->type][$r->id] = t('@name (@abbreviation)', array('@name' => $r->name, '@abbreviation' => $r->abbreviation));
      }
      else {
        $options[$r->id] = t('@name (@abbreviation)', array('@name' => $r->name, '@abbreviation' => $r->abbreviation));
      }
    }
  }

  return $options;
}

/**
 * Converts a recipe ingredient name to and ID
 */
function recipe_ingredient_id_from_name($name) {
  static $cache;

  if (!$cache[$name]) {
    $ingredient_id = db_result(db_query("SELECT id FROM {recipe_ingredient} WHERE LOWER(name)='%s'", trim(strtolower($name))));

    if (!$ingredient_id) {
      global $active_db;
      $node_link = db_result(db_query("SELECT nid FROM {node} WHERE title = '%s'", $name));
      if (!$node_link) {
        $node_link = 0;
      }
      db_query("INSERT INTO {recipe_ingredient} (name, link) VALUES ('%s', %d)", $name, $node_link);
      $ingredient_id = db_result(db_query("SELECT id FROM {recipe_ingredient} WHERE LOWER(name)='%s'", trim(strtolower($name))));
    }
    $cache[$name] = $ingredient_id;
  }

  return $cache[$name];
}

/**
 * Converts an ingredient's quantity from decimal to fraction
 */
function recipe_ingredient_quantity_from_decimal($ingredient_quantity) {
  if (strpos($ingredient_quantity, '.') && variable_get('recipe_fraction_display', t('{%d} %d&frasl;%d'))) {
    $decimal = abs($ingredient_quantity);
    $whole = floor($decimal);
    $numerator = 0;
    $denominator = 1;
    $top_heavy = 0;

    $power = 1;
    $flag = 0;
    while ($flag == 0) {
      $argument = $decimal * $power;
      if ($argument == floor($argument)) {
        $flag = 1;
      }
      else {
        $power = $power * 10;
      }
    }


    // We have to workaround for repeating, non-exact decimals for thirds, sixths, ninths, twelfths.
    $overrides = array(
      '3333' => array(1, 3), '6666' => array(2, 3), '9999' => array(3, 3), // thirds
      '1666' => array(1, 6), '8333' => array(5, 6), // sixths
      '1111' => array(1, 9), '2222' => array(2, 9), '4444' => array(4, 9), '5555' => array(5, 9), '7777' => array(7, 9), '8888' => array(8, 9), // ninths
      '0833' => array(1, 12), '4166' => array(5, 12), '5833' => array(7, 12), '9166' => array(11, 12), // twelfths
    );
    // truncate the whole part to get just the fractional part
    $conversionstr = substr((string) ($decimal - floor($decimal)), 2, 4);
    if (array_key_exists($conversionstr, $overrides)) {
      if ($overrides[$conversionstr][0] == $overrides[$conversionstr][1]) {
          return ($whole + 1);
      }
      $denominator = $overrides[$conversionstr][1];
      $numerator   = (floor($decimal) * $denominator) + $overrides[$conversionstr][0];
    }
    else {
      $numerator = $decimal * $power;
      $denominator = $power;
    }


    // repeating decimals have been corrected
    $gcd = greatest_common_divisor($numerator, $denominator);

    $numerator = $numerator/$gcd;
    $denominator = $denominator/$gcd;
    $top_heavy = $numerator;

    $numerator = abs($top_heavy) - (abs($whole) * $denominator);

    $ingredient_quantity = sprintf(variable_get('recipe_fraction_display', t('{%d} %d&frasl;%d')), $whole, $numerator, $denominator);

    if (($whole == 0) && (strpos($ingredient_quantity, '{') >= 0)) {
      // Remove anything in curly braces.
      $ingredient_quantity = preg_replace('/{.*}/', '', $ingredient_quantity);
    }
    else {
      // Remove just the curly braces, but keep everything between them.
      $ingredient_quantity = preg_replace('/{|}/', '', $ingredient_quantity);
    }
  }

  return filter_xss_admin($ingredient_quantity);
}

/**
 * Find the greatest common divisor
 */
function greatest_common_divisor ($a, $b) {
  while ( $b != 0) {
    $remainder = $a % $b;
    $a = $b;
    $b = $remainder;
  }
  return abs($a);
}


/**
 * Converts an ingredient's quantity from fractions to decimal.
 */
function recipe_ingredient_quantity_from_fraction($ingredient_quantity) {
  if ($pos_slash = strpos($ingredient_quantity, '/')) {
    $pos_space = strpos($ingredient_quantity, ' ');

    // Can't trust $pos_space to be a zero value if there is no space
    // so set it explicitly.
    if ($pos_space === FALSE) {
      $pos_space = 0;
    }

    $whole = substr($ingredient_quantity, 0, $pos_space);
    $numerator = substr($ingredient_quantity, $pos_space, $pos_slash);
    $denominator = substr($ingredient_quantity, $pos_slash + 1);
    $ingredient_quantity = $whole+($numerator/$denominator);
  }

  return $ingredient_quantity;
}

/**
 * Saves the changed ingredients of a recipe node to the database
 * (by comparing the old and new ingredients first)
 */
function recipe_save_ingredients($node) {
  if (!$node->ingredients) {
    $node->ingredients = array();
  }
  $changes = recipe_ingredients_diff($node->ingredients, recipe_load_ingredients($node));

  if (count($changes->remove) > 0) {
    db_query("DELETE FROM {recipe_node_ingredient} WHERE id IN (" . db_placeholders($changes->remove, 'int') . ")", $changes->remove);
  }

  foreach ($changes->add as $ingredient) {
    $ingredient->id = recipe_ingredient_id_from_name($ingredient->name);
    $ingredient->quantity = recipe_ingredient_quantity_from_fraction($ingredient->quantity);
    db_query("INSERT INTO {recipe_node_ingredient} (nid, ingredient_id, quantity, unit_id, weight) VALUES (%d, %d, %f, %d, %d)", $node->nid, $ingredient->id, $ingredient->quantity, $ingredient->unit_id, $ingredient->weight);
  }

  foreach ($changes->update as $ingredient) {
    $ingredient->id = recipe_ingredient_id_from_name($ingredient->name);
    $ingredient->quantity = recipe_ingredient_quantity_from_fraction($ingredient->quantity);
    db_query("UPDATE {recipe_node_ingredient} SET quantity = %f, unit_id = %d, weight = %d WHERE nid = %d AND ingredient_id = %d", $ingredient->quantity, $ingredient->unit_id, $ingredient->weight, $node->nid, $ingredient->id);
  }
}

/**
 * Compares two arrays of ingredients and returns the differences.
 */
function recipe_ingredients_diff($a1, $a2) {
  $return->add = array();
  $return->remove = array();
  $return->update = array();

  foreach ($a1 as $key => $pl) {
    $pl = (object)$pl;
    $pl->weight = $key;
    $pl->name = trim($pl->name);
    if ($pl->name) {
      if (!_in_array($pl, $return->add)) {
        // Duplicate entries for the same ingredient are ignored.
        if (!_in_array($pl, $a2)) {
          $return->add[] = $pl;
        }
        elseif (!_in_array($pl, $return->update)) {
          $return->update[] = $pl;
        }
      }
    }
  }

  foreach ($a2 as $k => $pl) {
    if (!_in_array($pl, $a1)) {
      $return->remove[] = $pl->id;
    }
  }

  return $return;
}

/**
 * Custom in_array() function because PHP 4 in_array() does not seem to
 * handle the first argument being an object.
 */
function _in_array($a, $b) {
  $a->name = trim(strtolower($a->name));
  foreach ($b as $row) {
    $compareto="";
    if (is_array($row)) {
      $compareto = trim(strtolower($row["name"]));
    }
    else {
      $compareto = trim(strtolower($row->name));
    }
    if ($a->name === $compareto) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Loads the ingredients for a recipe
 */
function recipe_load_ingredients($node) {
  $rs = db_query("
  SELECT
    ri.id,
    i.name,
    i.link,
    ri.quantity,
    ri.unit_id,
    ri.weight,
    u.abbreviation,
    ri.ingredient_id
  FROM
    {recipe_node_ingredient} ri,
    {recipe_ingredient} i,
    {recipe_unit} u
  WHERE
    ri.ingredient_id = i.id
    AND ri.unit_id = u.id
    AND ri.nid = %d
  ORDER BY
  ri.weight, ri.id", $node->nid);

  $ingredients = array();
  while ($ingredient = db_fetch_object($rs)) {
    $ingredients[] = $ingredient;
  }

  return $ingredients;
}

/**
 * Converts a recipe unit ID to it's abbreviation
 */
function recipe_unit_abbreviation($unit_id) {
  static $abbreviations;

  if (!$abbreviations) {
    $rs = db_query("SELECT id, abbreviation FROM {recipe_unit}");
    while ($unit = db_fetch_object($rs)) {
      $abbreviations[$unit->id] = $unit->abbreviation;
    }
  }

  return $abbreviations[$unit_id];
}

/**
 * Converts a recipe unit ID to it's name */
function recipe_unit_name($unit_id) {
  static $unit_names;

  if (!$unit_names) {
    $rs = db_query("SELECT id, name FROM {recipe_unit}");
    while ($unit = db_fetch_object($rs)) {
      $unit_names[$unit->id] = $unit->name;
    }
  }

  return $unit_names[$unit_id];
}


/**
 * Menu callback; Generates various representation of a recipe page with
 * all descendants and prints the requested representation to output.
 *
 * @param type
 *   - a string encoding the type of output requested.
 * @param nid
 *   - an integer representing the node id (nid) of the node to export
 */
function recipe_export($type = 'html', $nid = NULL, $yield = NULL) {
  // normalize typed urls
  $type = drupal_strtolower($type);

  // load supported formats
  $formats = module_invoke_all('recipeio', 'export_single');

  // If callback exists, call it, otherwise error out.
  if (isset($formats[$type]) && function_exists($formats[$type]['callback'])) {
    echo call_user_func($formats[$type]['callback'], $nid, $yield);
  }
  else {
    drupal_set_message(t('Unknown export format.') . '(' . $type . ')');
    drupal_not_found();
  }
}

function recipe_export_multi($type = NULL) {

  // load supported formats
  $formats = module_invoke_all('recipeio', 'export_multi');
  $o = 'Supported Output Formats:<br/>';
  if ( $type === NULL ) {
    foreach ( $formats as $key => $format ) {
      $o .= l($format['format_name'], "recipe/export_multi/$key") . "<br/>";
    }
    return $o;
  }

  // normalize typed urls
  $type = drupal_strtolower($type);

  // If callback exists, call it, otherwise error out.
  if (isset($formats[$type]) && function_exists($formats[$type]['callback'])) {
    echo call_user_func($formats[$type]['callback']);
  }
  else {
    drupal_set_message(t('Unknown export format.') . '(' . $type . ')');
    drupal_not_found();
  }
}



/**
 * Callback function for ingredient autocomplete
 */
function recipe_autocomplete_page($string = "", $limit = 10) {
  $matches = array();
  $rs = db_query("SELECT name FROM {recipe_ingredient} WHERE LOWER(name) LIKE '%s%%' ORDER BY name LIMIT %d", strtolower($string), $limit);
  while ($r = db_fetch_object($rs)) {
    $matches[$r->name] = check_plain($r->name);
  }
  print drupal_to_js($matches);
  exit();
}

/**
 * Implementation of hook_validate().
 *
 * Errors should be signaled with form_set_error().
 */
function recipe_validate($node, &$form) {

  if ( !is_numeric($node->yield) || $node->yield <=0 ) {
    form_set_error('yield', t('Yield must be a valid positive integer.'));
  }

  if (!$node->ingredients) return;
  $ingredients = array();
  foreach ($node->ingredients as $key => $ingredient) {
    $ingredient = (object)$ingredient;
    if (!isset($ingredient->quantity)) {
      $ingredient = recipe_parse_ingredient_string($ingredient->name);
    }
    if ($ingredient->name && _in_array($ingredient, $ingredients)) {
      form_set_error('recipe', t('Duplicate ingredients are not allowed.'));
    }
    else {
      $ingredients[] = $ingredient;
    }
    $node->ingredients[$key] = $ingredient;
  }
}

/**
 * Converts an ingredients name string to an ingredient object.
 */
function recipe_parse_ingredient_string($ingredient_string) {
  if (preg_match('#([0-9.]+(?:\s?\d*/\d*)?\s?)?(?:([a-zA-Z.]*)\s)?(.*)#', trim($ingredient_string), $matches)) {
    $ingredient->name = $matches[3];
    $ingredient->quantity = trim($matches[1]);
    if ($ingredient->quantity == 0) {
      $ingredient->quantity = 0;
    }
    $t_unit = $matches[2];
    $unit = recipe_unit_from_name($t_unit);

    if ($unit) {
      $ingredient->unit_id = $unit->id;
      $ingredient->abbreviation = $unit->abbreviation;
    }
    else {
      $ingredient->unit_id = 29;
      $ingredient->abbreviation = '';
      $ingredient->name = $t_unit .' '. $ingredient->name;
    }

    $ingredient->name = trim($ingredient->name);

    return $ingredient;
  }
  else {
    return FALSE;
  }
}

/**
 * Returns information about a unit based on a unit abbreviation or name
 */
function recipe_unit_from_name($name) {
  if (strlen($name) > 1)
    $string = strtolower($name);
  else
    $string = $name;
  $ending = substr($string, -1, 1);
  if ($ending == 's'  && $string != 'ds' || $ending == '.') {
    $string = substr($string, 0, strlen($string) -1);
  }
  $ending = substr($string, -1, 1);
  if ($ending == 's'  && $string != 'ds'|| $ending == '.') {
    $string = substr($string, 0, strlen($string) -1);
  }

  static $units_array;

  if (!$units_array) {
    $rs = db_query("SELECT id, name, abbreviation FROM {recipe_unit}");
    while ($unit = db_fetch_object($rs)) {
      $units_array[strtolower($unit->name)] = $unit;
      $units_array[$unit->abbreviation] = $unit;
    }
  }

  return $units_array[$string];
}

/**
 * Menu Callback - created output for the main recipe page.
 *
 * @return
 *   $body
 */
function recipe_page() {
  $body = "";

  if (arg(1) == 'feed') {
    module_invoke('node', 'feed', module_invoke('taxonomy', 'select_nodes', recipe_get_recipe_terms(), 'or', 0, FALSE));
  }
  else {
    if (arg(1) != NULL) {
      $breadcrumb = drupal_get_breadcrumb();
      $term = recipe_build_breadcrumbs($breadcrumb);
      drupal_set_breadcrumb($breadcrumb);

      if ($term != NULL) {
        $content = recipe_index($term->tid);
        if ($content != '') {
          $body = theme('box', t('@term-name - Sub categories', array('@term-name' => $term->name)), $content);
        }

        $terms = array_merge(array($term->tid), array_map('_recipe_get_tid_from_term', module_invoke('taxonomy', 'get_children', $term->tid)));
        $body .= module_invoke('taxonomy', 'render_nodes', module_invoke('taxonomy', 'select_nodes', $terms));
      }
    }
    else {
      // This is the normal page display
      $body = '';
      if (variable_get('recipe_recent_box_enable', 1)) {
        // link to add new content on Page, if user has access
        if (user_access('create recipes', $account)) {
              $body = "<div class='recipe-add-content'><a href='/node/add/recipe'>Add a Recipe</a></div>";
        }
        $body .= theme('box', variable_get('recipe_recent_box_title', t('Latest recipes')), module_invoke('node', 'title_list', recipe_get_latest(variable_get('recipe_recent_display', '5')), '') . theme('recipe_more_info', theme('feed_icon', url("recipe/feed"), t('Syndicate'))));
      }
      $content = recipe_index();
      if ($content != '') {
        $body .= theme('box', t('Recipe categories'), $content);
      }
    }
  }
  return $body;
}

/**
 * Builds a breadcrumb list.
 *
 * @param
 *   breadcrumb a reference to the breadcrumb array. New items will be appending to this array.
 * @return
 *   returns a term object if the last item in the url is a term, otherwise returns NULL.
 */
function recipe_build_breadcrumbs(&$breadcrumb) {
  if (arg(1) != NULL) {
    $i = 1;
    $url = 'recipe';
    $breadcrumb[] = l(t('Recipes'), $url);
    while (arg($i) != NULL) {
      $last_term = urldecode(arg($i));
      $url = $url .'/'. urlencode($last_term);
      $breadcrumb[] = l($last_term, $url);
      $i++;
    }

    $term = current(module_invoke('taxonomy', 'get_term_by_name', $last_term));
    return $term;
  }
  return NULL;
}

/**
 * Recursively traverses the term tree to construct the index.
 *
 * @return
 *   String the output for this tree.
 */
function recipe_build_index(&$tree, $parent_url) {
  $output = '';

  if ($tree == array()) {
    return '';
  }

  do {
    $cur = current($tree);
    $nex = next($tree);
    if ($nex === FALSE) {
      $next_depth = -1;
    }
    else {
      $next_depth = $nex->depth;
    }

    $cur->link = $parent_url .'/'. urlencode(strtolower(trim($cur->name)));

    $cur->children = '';
    if ($next_depth > $cur->depth) {
      $cur->children = recipe_build_index($tree, $cur->link);

      // Sync $next_depth, because 'next item' may be shoved forward.
      // Thanks for the patch Roderik.
      $nex = current($tree);
      if ($nex === FALSE) {
        $next_depth = -1;
      }
      else {
        $next_depth = $nex->depth;
      }
    }

    $cur->count = module_invoke('taxonomy', 'term_count_nodes', ($cur->tid));

    $output .= theme('recipe_index_item', $cur);
  }
  while ($cur->depth == $next_depth);

  return theme('recipe_list', $output);
}

/**
 * Constructs a url from the current url arguments list.
 *
 * @return
 *   A string containing a formated URL.
 */
function recipe_get_current_url() {
  $arg_index = 1;
  $url = arg(0);

  while ($argument = arg($arg_index)) {
    $url .= '/'. urlencode($argument);
    $arg_index++;
  }

  return $url;
}

/**
 * Get the latest recipes.
 *
 * @return
 *   A database query result.
 */
function recipe_get_latest($count = 0) {
  $tids = recipe_get_recipe_terms();
  return recipe_select_nodes($tids, 'or', 0, FALSE, $count);
}

/**
 * Get all the terms associated with recipes.
 *
 * @return
 *   An array of unique term ids.
 */
function recipe_get_recipe_terms() {
  $vocabs = recipe_get_vocabularies();
  $tids = array();
  foreach ($vocabs as $vocab) {
    $tids = array_merge($tids, recipe_tax_get_terms($vocab->vid));
  }
  return array_unique($tids);
}

/**
 * Gets all the vocabularies that are associated with the recipe module.
 *
 * @return
 *   Array the vocabularies.
 */
function recipe_get_vocabularies() {
  $vocabularies = module_invoke('taxonomy', 'get_vocabularies', 'recipe');
  return $vocabularies;
}

/**
 * Constructs the recipe index page, using theme functions.
 *
 * @return
 *   A string containing the output ready for display.
 */
function recipe_index($tid = 0) {
  $output = '';

  $vocabularies = recipe_get_vocabularies();
  foreach ($vocabularies as $vocab) {
    $max_depth = variable_get('recipe_index_depth', 0);
    $vocab_tree = module_invoke('taxonomy', 'get_tree', $vocab->vid, $tid, -1, ($max_depth <= 0) ? NULL : $max_depth);
    $content = '';

    while (current($vocab_tree) != NULL) {
      $content .= recipe_build_index($vocab_tree, recipe_get_current_url());
    }

    if ($content != '') {
      $output .= theme('recipe_index', $vocab->name, $content);
    }
  }

  return $output;
}

/**
 * Custom version of node_prepare().
 *
 */
function recipe_node_prepare($node, $teaser = FALSE) {
  $node->readmore = TRUE;
  if ($teaser == FALSE) {
    $node->body = check_markup($node->body, $node->format, FALSE);
    $node->instructions = check_markup($node->instructions, $node->format, FALSE);
    if ($node->notes) {
      $node->notes = check_markup($node->notes, $node->format, FALSE);
    }
    if ($node->source) {
      $node->source = check_markup($node->source, $node->format, FALSE);
    }
    if ($node->ingredients) {
      $tmp = $node->ingredients;
      $node->ingredients = array();
      foreach ($tmp as $ingredient) {
        // For preview, node->ingredients is an array, for actual display, it's an object
        if (is_array($ingredient)) {
          if (isset($ingredient['name'])) {
            $ingredient['name'] = check_plain($ingredient['name']);
          }
        }
        elseif (is_object($ingredient)) {
          if (isset($ingredient->name)) {
            $ingredient->name = check_plain($ingredient->name);
          }
        }
        $node->ingredients[] = $ingredient;
      }
    }
  }
  else {
    $node->teaser = check_markup($node->body, $node->format, FALSE);
  }

  return $node;
}

/**
 * Finds all nodes that match selected taxonomy conditions.
 * This is just a copy of taxonomy_select_nodes(), but includes node title
 * field in the selection.
 * Is this useful or try to find a taxonomy function to achieve this?
 *
 * @param $tids
 *   An array of term IDs to match.
 * @param $operator
 *   How to interpret multiple IDs in the array. Can be "or" or "and".
 * @param $depth
 *   How many levels deep to traverse the taxonomy tree. Can be a nonnegative
 *   integer or "all".
 * @param $pager
 *   Whether the nodes are to be used with a pager (the case on most Drupal
 *   pages) or not (in an XML feed, for example).
 * @return
 *   A resource identifier pointing to the query results.
 */
function recipe_select_nodes($tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $count = 0) {
  if (count($tids) > 0) {
    // For each term ID, generate an array of descendant term IDs to the right depth.
    $descendant_tids = array();
    if ($depth === 'all') {
      $depth = NULL;
    }
    foreach ($tids as $index => $tid) {
      $term = module_invoke('taxonomy', 'get_term', $tid);
      $tree = module_invoke('taxonomy', 'get_tree', $term->vid, $tid, -1, $depth);
      $descendant_tids[] = array_merge(array($tid), array_map('_recipe_get_tid_from_term', $tree));
    }

    // TODO: Use db_placeholder()
    if ($operator == 'or') {
      $str_tids = implode(',', call_user_func_array('array_merge', $descendant_tids));
      if (module_exists('category')) {
        $sql = 'SELECT DISTINCT n.nid, n.title, n.sticky, n.created FROM {node} n INNER JOIN {category_node} cn ON n.nid = cn.nid WHERE cn.cid IN ('. $str_tids .') AND n.status = 1 ORDER BY n.sticky DESC, n.created DESC';
        $sql_count = 'SELECT COUNT(n.nid) FROM {node} n INNER JOIN {category_node} cn ON n.nid = cn.nid WHERE cn.tid IN ('. $str_tids .') AND n.status = 1';
      }
      else {
        $sql = 'SELECT DISTINCT n.nid, n.title, n.sticky, n.created FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid WHERE tn.tid IN ('. $str_tids .') AND n.status = 1 ORDER BY n.sticky DESC, n.created DESC';
        $sql_count = 'SELECT COUNT(n.nid) FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid WHERE tn.tid IN ('. $str_tids .') AND n.status = 1';
      }
    }
    else {
      $joins = '';
      $wheres = '';
      if (module_exists('category')) {
        foreach ($descendant_tids as $index => $tids) {
          $joins .= ' INNER JOIN {category_node} cn'. $index .' ON n.nid = cn'. $index .'.nid';
          $wheres .= ' AND cn'. $index .'.cid IN ('. implode(',', $tids) .')';
        }
      }
      else {
        foreach ($descendant_tids as $index => $tids) {
          $joins .= ' INNER JOIN {term_node} tn'. $index .' ON n.nid = tn'. $index .'.nid';
          $wheres .= ' AND tn'. $index .'.tid IN ('. implode(',', $tids) .')';
        }
      }
      $sql = 'n.nid, n.title, n.sticky, n.created FROM {node} n '. $joins .' WHERE n.status = 1 AND '. $wheres .' ORDER BY n.sticky DESC, n.created DESC';
      $sql_count = 'SELECT COUNT(n.nid) FROM {node} n '. $joins .' WHERE n.status = 1 AND '. $wheres;
    }
  }
  else {
    // no taxonomy used
    $sql = "SELECT nid, title, sticky, created FROM {node} n WHERE status = 1 AND type = 'recipe' ORDER BY sticky DESC, created DESC";
    $sql_count = "SELECT COUNT(nid) FROM {node} n  WHERE status = 1 AND type = 'recipe'";
  }

  if ($pager && ($count > 0)) {
    $result = pager_query(db_rewrite_sql($sql), variable_get('default_nodes_main', 10) , 0, db_rewrite_sql($sql_count));
  }
  else {
    $count = ($count > 0) ? $count : 15;
    $result = db_query_range(db_rewrite_sql($sql), 0, $count);
  }

  return $result;
}

/**
 * Get all the terms in a given vocabulary.
 *
 * @return
 *   An array of unique term ids.
 */
function recipe_tax_get_terms($vid) {
  $result = db_query("SELECT tid FROM {term_data} WHERE vid = %d", $vid);
  $tids = array();
  while ($term = db_fetch_array($result)) {
    $tids[] = $term['tid'];
  }
  return array_unique($tids);
}

/**
 * Hook into generic node creation/update and check if the added node
 * fixes any links in existing recipes.
 */
function recipe_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  switch ($op) {
    case 'insert':
    case 'update':
      if ($node->type == 'ingredient') {
        db_query("UPDATE {recipe_ingredient} SET link = %d WHERE LOWER(name) = '%s'", $node->nid, trim(strtolower($node->title)));
      }
      break;
  }
}

/**
 * Helper function for array map purposes.
 *
 * @param term
 *   The term object from which the tid will be extracted.
 * @return
 *   The tid member of $term.
 */
function _recipe_get_tid_from_term($term) {
  return $term->tid;
}

/**
 * Implementation of hook_theme().
 */
function recipe_theme() {
  return array(
    'recipe_node' => array(
      'function' => 'theme_recipe_node',
      'arguments' => array('node' => NULL, 'yield_form' => TRUE, 'yield_arg' => NULL),
    ),
    'recipe_index' => array(
      'function' => 'theme_recipe_index',
      'arguments' => array('name' => NULL, 'index_list' => NULL),
    ),
    'recipe_index_item' => array(
      'arguments' => array('term' => NULL),
    ),
    'recipe_list' => array(
      'arguments' => array('output' => NULL),
    ),
    'recipe_more_info' => array(
      'arguments' => array('content' => NULL),
    ),
  );
}

/**
 * A custom theme function.
 *
 * By using this function to format our node-specific information, themes
 * can override this presentation if they wish. We also wrap the default
 * presentation in a CSS class that is prefixed by the module name. This
 * way, style sheets can modify the output without requiring theme code.
 */
function theme_recipe_node($node, $display_yield_form = TRUE, $yield_arg = NULL) {
  // Get custom yield or default to a factor of 1.
  $node->yield = intval($node->yield);
  $factor = 1;

  // check post variable to see if the yield form was posted.
  if ($_POST['op'] == t('Change')) {
    $yield = $_POST['custom_yield'];
    $_POST = array();
  }
  elseif ($_POST['op'] == t('Halve')) {
      $yield = $_POST['custom_yield']/2;
      $_POST = array();
    }
  elseif ($_POST['op'] == t('Double')) {
    $yield = $_POST['custom_yield']*2;
    $_POST = array();
  }
  // Reset yield back to recipe default
  elseif ($_POST['op'] == t('Reset')) {
    $yield = $node->yield;
    $_POST = array();
  }

  // $yield_arg overrides the post if available
  if ( $yield_arg != NULL ) {
    $yield = $yield_arg;
  }

  // Figure out the yield factor and reset the node->yield.
  if ($yield && $yield != $node->yield && $node->yield !=0) {
    $factor = $yield / $node->yield;
    $node->yield = $yield;
  }

  // replace yield value with the yield form
  if ( $display_yield_form ) {
    $yield = drupal_get_form('recipe_custom_yield_form', $node);
  }
  else {
    $yield = $node->yield;
  }

  // Construct the $ingredients[] array.
  if ($node->ingredients) {
    foreach ($node->ingredients as $ingredient) {
      $ingredient = (object)$ingredient;
      if (isset($ingredient->quantity) && $ingredient->name) {
        if (!$ingredient->abbreviation) {
          $ingredient->abbreviation = recipe_unit_abbreviation($ingredient->unit_id);
        }
        if ($ingredient->abbreviation == '') {
          $ingredient->abbreviation = '&nbsp;';
        }
        if ($ingredient->quantity > 0) {
          $ingredient->quantity *= $factor;
        }
        else {
          $ingredient->quantity = '&nbsp;';
        }
        if (variable_get('recipe_fraction_display', t('{%d} %d&frasl;%d'))) {
          $ingredient->quantity = recipe_ingredient_quantity_from_decimal($ingredient->quantity);
        }
        if (!empty($ingredient->link)) {
          $ingredient->name = l($ingredient->name, 'node/'. $ingredient->link);
        }

        $ingredients[] = '<div class="qty">'. $ingredient->quantity .'</div><div class="acronym-wrap"><acronym ' . drupal_attributes(array('title' => recipe_unit_name($ingredient->unit_id))) . '">' . $ingredient->abbreviation .'</acronym></div> '. $ingredient->name;
      }
    }
  }

  // Construct the summary
  $summary = '<table>';
  $summary .= '<tr><th>'. t('Yield') .'</th><td>'. $yield .'</td></tr>';
  if ($node->source) {
    $summary .= '<tr><th>'. t('Source') .'</th><td>'. $node->source .'</td></tr>';
  }
  if ($node->preptime) {
    if ($node->preptime < 60) {
      $preptime = format_plural($node->preptime, '1 minute', '@count minutes');
    }
    elseif ($node->preptime % 60 == 0) {
      $preptime = format_plural($node->preptime / 60, '1 hour', '@count hours');
    }
    else {
      $preptime = t('!time hours', array('!time' => recipe_ingredient_quantity_from_decimal($node->preptime / 60)));
    }
    $summary .= '<tr><th>'. t('Prep time') .'</th><td>'. $preptime .'</td></tr>';
  }

  $vocabs = taxonomy_get_vocabularies('recipe');
  if (count($vocabs) > 0) {
    foreach ($vocabs as $vocab) {
      $summary .= '<tr><th>'. $vocab->name .'</th><td>';
      $terms = taxonomy_node_get_terms_by_vocabulary($node, $vocab->vid);
      foreach ( $terms as $term ) {
        $term = array_shift($terms);
        $summary .= l($term->name, 'taxonomy/term/'. $term->tid) .' ';
      }
      $summary .= '</td></tr>';
    }
  }
  $summary .= '</table>';

  // Create the output
  $output = '';
  if (variable_get('recipe_hide_summary', 0) == 0) {
    $output .= '<div class="recipe-summary">'. theme('box', t('Summary'), $summary ) .'</div>';
  }
  else {
    $output .= '<div class="recipe-summary" style="display:none">'. theme('box', t('Summary'), $summary ) .'</div>';
  }
  $output .= '<div class="recipe-description">'. theme('box', t('Description'), $node->body) .'</div>';
  $output .= '<div class="recipe-ingredients">'. theme('box', t('Ingredients'), theme('item_list', $ingredients)) .'</div>';
  $output .= '<div class="recipe-instructions">'. theme('box', t('Instructions'), $node->instructions) .'</div>';
  if ($node->notes !== '') {
    $output .= '<div class="recipe-notes">'. theme('box', t('Notes'), $node->notes) .'</div>';
  }

  return $output;
}

function recipe_custom_yield_form($form_id, $node) {
  $form['custom_yield_container'] = array(
    '#type' => 'fieldset',
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
  );
  $form['custom_yield_container']['custom_yield'] = array(
    '#type' => 'textfield',
    '#default_value' => $node->yield,
    '#size' => 2,
    '#maxlength' => 4,
  );
  $form['custom_yield_container']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Change'),
  );
  $form['custom_yield_container']['reset'] = array(
    '#type' => 'submit',
    '#value' => t('Reset'),
  );
  $form['custom_yield_container']['halve'] = array(
    '#type' => 'submit',
    '#value' => t('Halve'),
  );
  $form['custom_yield_container']['double'] = array(
    '#type' => 'submit',
    '#value' => t('Double'),
  );

  return $form;
}

/**
 * Controls the output of the rendered index list.
 *
 * @return
 *   String the output for the index list.
 */
function theme_recipe_index(&$name, &$index_list) {
  if ($index_list != '') {
    return "<div class='recipe-item-list'>\n" . $index_list . "\n</div>\n";
  }
  return '';
}

/**
 * Displays a single index item.
 *
 * @return
 *   String the output for this item.
 */
function theme_recipe_index_item(&$term) {
  $description = ($term->description != '') ? '<p class="recipe-desc">' . $term->description . '</p>' : '';
  if ($term->count > 0) {
    return '<li><div class="recipe-title">' . l(t('@term-name (@term-count)', array('@term-name' => $term->name, '@term-count' => $term->count)), $term->link) . '</div>' . $description . $term->children . '</li>';
  }
  else {
    return '<li><div class="recipe-title">'. t('@term-name (@term-count)', array('@term-name' => $term->name, '@term-count' => $term->count)) . '</div>' . $description . $term->children . '</li>';
  }
}

/**
 * Displays a single one level list. Called for each group of items at the same depth.
 *
 * @return
 *   String the output for this list.
 */
function theme_recipe_list(&$output) {
  if ($output != '') {
    return '<ul>' . $output . "</ul>\n";
  }
  return '';
}

/**
 * Displays more information content, such as "more" links, and feed images.
 *
 * @return
 *   Formatted string containing the output.
 */
function theme_recipe_more_info($content) {
  return '<div class="recipe-more-link">' . $content . '</div>';
}


/**
 * Form recipe_import_form
 */
function recipe_import_form($form_state) {

  $formats = module_invoke_all('recipeio', 'import_single');

  $options = array();
  foreach ( $formats as $format ) {
    $options[$format['callback']] = $format['format_name'];
  }

  if (isset($form_state['values']['recipe_preview'])) {
    $form['#prefix'] = $form_state['values']['recipe_preview'];
  }

  $form['recipe_format'] = array(
    '#type' => 'select',
    '#title' => t('Recipe format'),
    '#options' => $options,
    '#default_value' => $form_state['values']['recipe_format'],
    '#size' => 1,
    '#description' => t('The recipe input format.'),
  );

  $form['recipe_import_text'] = array(
    '#type' => 'textarea',
    '#title' => t('Paste import data here'),
    '#default_value' => $form_state['values']['recipe_import_text'],
    '#cols' => 55,
    '#rows' => 8,
    '#required' => TRUE,
    '#description' => t('Always use preview first to avoid unintended consequences.'),
  );

  $form['buttons']['preview'] = array(
    '#type' => 'submit',
    '#value' => t('Preview'),
    '#weight' => 1,
    '#submit' => array('recipe_import_form_preview'),
  );

  $form['buttons']['import'] = array(
    '#type' => 'submit',
    '#value' => t('Import'),
    '#weight' => 2,
    '#submit' => array('recipe_import_form_submit'),
  );

  return $form;
}


/**
 * Import preview routine that allows that users to see what actually will be imported before doing so.
 */
function recipe_import_form_preview($form, &$form_state) {
  drupal_add_css(drupal_get_path('module', 'recipe') .'/recipe.css');
  $recipe = recipe_import_parse($form, $form_state);

  if ( $recipe != FALSE ) {
    $preview = 'Recipe Name: ' . $recipe['title'] . "<br/><br/>";

    $preview .= 'Ingredients:<br/>=====<br/>';
    foreach ( $recipe['ingredients'] as $i ) {
      $preview .= $i['quantity'] . " ";
      if ( $i['unit_obj'] == FALSE ) {
        $preview .= '<span class="recipe-new-item" title="New, unit not found in database">' . $i['unit_name'] . "*</span> ";
      }
      else {
        $preview .= '<span class="recipe-matched-item" title="Found, unit in database">' . $i['unit_name'] . "&radic;</span> ";
      }

      if ( $i['ingred_obj'] == FALSE ) {
        if ( preg_match('/^failed:/i', $i['ingredient_name']) ) {
          $preview .= '<span class="recipe-error-item" title="Error, ingredient line unreadable">' . $i['ingredient_name'] . '</span>';
        }
        else {
          $preview .= '<span class="recipe-new-item" title="New, ingredient not found in database">' . $i['ingredient_name'] . '*</span>';
        }
      }
      else {
        $preview .= '<span class="recipe-matched-item" title="Found, ingredient in database">' . $i['ingredient_name'] . "&radic;</span>";
      }
      $preview .= '<br/>';
    }

    $preview .= '<br/>Instructions:<br/>=====<br/>' . $recipe['instructions'] . "<br/>";

    $form_state['values']['recipe_preview'] = '<div class="recipe-preview">' . $preview . '</div>';
    $form_state['rebuild'] = TRUE;
    drupal_set_title(t('Import Preview'));
  }
}

/**
 * Import preview routine that allows that users to see what actually will be imported before doing so.
 */
function recipe_import_form_submit($form, &$form_state) {
  global $user;
  $recipe = recipe_import_parse($form, $form_state);
  if ($recipe) {
    //node stuff
    $node = new stdClass();
    $node->title = $recipe['title'];
    $node->body = $recipe['title'] . ' imported from Recipe Import';
    $node->type = 'recipe';
    $node->uid = $user->uid;
    $node->promote = 1;

    //recipe stuff
    $node->source = $user->name;
    $node->yield = 1;
    $node->notes = '';
    $node->instructions = $recipe['instructions'];
    $node->preptime = 60;

    //ingredients, have to change them into node->ingredients format
    $ingredient_list = array();
    foreach ($recipe['ingredients'] as $i) {
      $ingredient = new stdClass();
      $ingredient->quantity = $i['quantity'];
      if ( $i['unit_obj'] != FALSE ) {
        $ingredient->unit_id = $i['unit_obj']['id'];
      }
      $ingredient->name = $i['ingredient_name'];

      $ingredient_list[] = $ingredient;
    }
    $node->ingredients = $ingredient_list;
    node_save($node);
    $form_state['redirect'] = 'node/'. $node->nid .'/edit';
    drupal_set_message('Recipe Imported');
  }

}




/**
 * Import parsing controller which loads the actual parsing instances based on recipe_format.
 *
 * All parser instances should return a $recipe object that looks like this:
 *
 * $recipe = array(
 *   'title' => 'recipe title string',
 *   'ingredients' => array of ingredients items(below);
 *   'instuctions' => 'string of instructions'
 * );
 *
 * ingredients items = array(
 *    'quantity' =>
 *    'ingredient_name' =>
 *    'unit_name' =>
 *    'unit_obj' => comes from database lookup: see recipe_unit_fuzzymatch().  ==FALSE if no-match
 *    'ingre_obj' => comes from database lookup: see recipe_ingredient_match().  ==FALSE if no-match
 * );
 *
 */
function recipe_import_parse($form, &$form_state) {
  $import_function = $form_state['values']['recipe_format'];
  $text = $form_state['values']['recipe_import_text'];

  $recipe = array();
  if (function_exists($import_function)) {
    $recipe = call_user_func($import_function, $text);
    return $recipe;
  }
  else {
    drupal_set_message('recipe: '. $import_function . '() does not exist.' , 'error');
    return FALSE;
  }
}


/**
 * Fetch a recipe_unit.
 *
 * @param $recipe_name_or_abbrev
 *   A string representing an approximation of a unit abbreviation or a unit name.
 * @return
 *   A recipe_unit array upon successful load or FALSE
 */
function recipe_unit_fuzzymatch($recipe_name_or_abbrev, $reset = FALSE) {
  static $units;

  if ( !isset($units) || $reset ) {
    // get all units to prepare for fuzzy match
    $units = array();
    $result = db_query("SELECT id, name, abbreviation FROM {recipe_unit}");
    while ($row = db_fetch_object($result)) {
      $units[] = $row;
    }
  }
  foreach ( $units as $u ) {
    $name_pat = '^'. $u->name . 's{0,1}$';
    $abbrev_pat = '^'. $u->abbreviation . 's{0,1}\.{0,1}$';
    if ( preg_match("/$name_pat|$abbrev_pat/i", $recipe_name_or_abbrev) ) {
      return array(
        'id' => $u->id,
        'name' => $u->name,
        'abbreviation' => $u->abbreviation
      );
    }
  }
  return FALSE;
}


/**
 * Fetch an ingredient.
 *
 * @param $recipe_ingredient_name
 *   A string representing a recipe_ingredient_name.
 * @return
 *   A recipe_ingredient array upon successful load or FALSE
 */
function recipe_ingredient_match($recipe_ingredient_name) {
  $result = db_query("SELECT id, name FROM {recipe_ingredient} where name='%s'", $recipe_ingredient_name);
  while ($row = db_fetch_object($result)) {
    return array(
      'id' => $row->id,
      'name' => $row->name
    );
  }
  return FALSE;
}


/**
 * Extend user_access to handle case where no import formats are available
 */
function recipe_import_access($string, $account = NULL, $reset = FALSE) {

  // short circuit if there are no parsers available.
  $formats = module_invoke_all('recipeio', 'import_single');
  if ( count($formats) == 0 ) {
    return FALSE;
  }
  // we have a format so continue to user_access
  return user_access($string, $account, $reset);
}


/**
 * Extend user_access to handle case where no export formats are available
 */
function recipe_export_multi_access($string, $account = NULL, $reset = FALSE) {

  // short circuit if there are no parsers available.
  $formats = module_invoke_all('recipeio', 'export_multi');
  if ( count($formats) == 0 ) {
    return FALSE;
  }
  // we have a format so continue to user_access
  return user_access($string, $account, $reset);
}
