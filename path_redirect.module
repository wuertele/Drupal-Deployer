<?php
//$Id$

/**
 * Implementation of hook_help
 *
 */
function path_redirect_help($path, $arg) {
  switch ($path) {
    case 'admin/build/path_redirect':
      return t("<p>Here you can set up URL redirecting for this site. Any existing or non-existing path within this site can redirect to any internal or external URL. </p>");      
    case 'admin/build/path_redirect/'. $arg[2]:
    case 'admin/build/path_redirect/edit/'. $arg[3]:
      return t("<p>The <strong>from</strong> path must be an internal Drupal path in the form of 'node/123', 'admin/logs', or 'taxonomy/term/123'. The <strong>to</strong> path can be either an internal Drupal path as above or a complete external URL such as http://www.example.com/. Furthermore, the <strong>to</strong> path may contain query arguments (such as 'page=2') and fragment anchors, to make it possible to redirect to 'admin/user?page=1#help'. Most redirects will not contain queries or anchors.</p>");
  }
}

/**
 * Implementation of hook_init
 * 
 * Early checking of URL requested.
 * If a match is found, user is redirected using drupal_goto()
 */
function path_redirect_init() {
  // see if this page has a redirect path
  $query = '';
  if (isset($_SERVER['QUERY_STRING'])) {
    $query = preg_replace('/^q=([^&]*).*$/', '\1', $_SERVER['QUERY_STRING']);
  }
  $r = db_fetch_object(db_query("SELECT redirect, query, fragment, type FROM {path_redirect} WHERE path = '%s' OR path = '%s'", $query, utf8_encode($query)));
  if ($r) {
    // if there's a result found, do the redirect
    drupal_goto($r->redirect, ($r->query ? $r->query: NULL), ($r->fragment ? $r->fragment : NULL), $r->type);
  }
}

/**
 * Implementation of hook_menu
 */
function path_redirect_menu() {
  $items['admin/build/path_redirect'] = array(
    'title' => 'URL redirects',
    'description' => 'Redirect users from one URL to another.',
    'page callback' => 'path_redirect_admin',
    'access arguments' => array('administer redirects'),
    'file' => 'path_redirect.admin.inc',
  );
  $items['admin/build/path_redirect/edit'] = array(
    'title' => 'Edit',
    'description' => 'Edit an existing URL redirect',
    'page callback' => 'path_redirect_admin',
    'type' => MENU_CALLBACK,
    'access arguments' => array('administer redirects'),
    'file' => 'path_redirect.admin.inc',
  );
  $items['admin/build/path_redirect/list'] = array(
    'title' => 'List',
    'description' => 'List all redirects',
    'access arguments' => array('administer redirects'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/build/path_redirect/add'] = array(
    'title' => 'Add redirect',
    'description' => 'Add a new URL redirect',
    'page callback' => 'path_redirect_admin_edit',
    'type' => MENU_LOCAL_TASK,
    'access arguments' => array('administer redirects'),
    'file' => 'path_redirect.admin.inc',
  );    
  $items['admin/build/path_redirect/delete'] = array(
    'title' => 'Delete redirect',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('path_redirect_admin_delete_confirm'),
    'type' => MENU_CALLBACK,
    'file' => 'path_redirect.admin.inc',
  );
  return $items;
}

/**
 * Implementation of hook_perm
 */
function path_redirect_perm() {
  return array('administer redirects');
}

function path_redirect_save($edit) {
  if (!empty($edit['rid'])) {
    $return = db_query("UPDATE {path_redirect} SET path = '%s', redirect = '%s', query = '%s', fragment = '%s', type = %d WHERE rid = %d", $edit['path'], $edit['redirect'], $edit['query'], $edit['fragment'], $edit['type'], $edit['rid']);
  }
  else {
    $return = db_query("INSERT INTO {path_redirect} (path, redirect, query, fragment, type) VALUES ('%s', '%s', '%s', '%s', '%s')", $edit['path'], $edit['redirect'], $edit['query'], $edit['fragment'], $edit['type']);
  }
  return $return;
}

/**
 * Retrieve the given URL redirect
 */
function path_redirect_load($rid) {
  return db_fetch_array(db_query("SELECT rid, path, redirect, query, fragment, type FROM {path_redirect} WHERE rid = %d", $rid));
}

/**
 * Delete the specified path redirect. This will delete as specifically as
 * possible, in order: by $rid, by ($from, $to), by $from, or by $to.
 * Multiple redirects may be deleted if the $to parameter matches more than
 * one entry.
 *
 * This function is part of an API available for external code to use.
 *
 * @param $from
 *   Source path of redirect to delete.
 * @param $to
 *   Destination path or URL of redirect to delete.
 * @param $rid
 *   Unique ID of redirect to delete.
 * @return
 *   The result of the deletion query.
 */
function path_redirect_delete($from = NULL, $to = NULL, $rid = NULL) {
  if (!empty($rid)) {
    $result = db_query("DELETE FROM {path_redirect} WHERE rid = %d", $rid);
  }
  else if (!empty($from)) {
    if (!empty($to)) {
      $result = db_query("DELETE FROM {path_redirect} WHERE path = '%s' AND redirect = '%s'", $from, $to);
    }
    else {
      $result = db_query("DELETE FROM {path_redirect} WHERE path = '%s'", $from);
    }
  }
  else if (!empty($to)) {
    $result = db_query("DELETE FROM {path_redirect} WHERE redirect = '%s'", $to);
  }
  return $result;
}

