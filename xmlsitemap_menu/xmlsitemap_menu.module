<?php
// $Id$

/**
 * @file
 * Adds menu items to the site map.
 */

/**
 * @addtogroup xmlsitemap
 * @{
 */

/*****************************************************************************
 * Drupal hooks.
 ****************************************************************************/

/**
 * Implementation of hook_xmlsitemap_description().
 */
function xmlsitemap_menu_xmlsitemap_description() {
  return '<dt>'. t('XML Sitemap: Menu') .'</dt>'.
    '<dd>'. t('The module allows menu items to be added to the site map. You can choose the menus to include on the XML Sitemap administration page and can add and remove menu items on the <a href="@menu">menu administration</a> page. The priority of a menu item is determined by its weight.', array('@menu' => url('admin/build/menu'))) .'</dd>';
}

/**
 * Implementation of hook_xmlsitmap_links().
 */
function xmlsitemap_menu_xmlsitemap_links() {
  $menus = variable_get('xmlsitemap_menu_menus', array());
  foreach ($menus as $menu) {
    $result = db_query("SELECT ml.*, m.*
      FROM {menu_links} ml
      INNER JOIN {menu_router} m ON m.path = ml.router_path
      WHERE  ml.menu_name = '%s'
      ORDER BY ml.plid, ml.mlid ASC",
      $menu
    );
    $row = new stdClass();
    $row->module = 'xmlsitemap_menu';
    while ($link = db_fetch_array($result)) {
      // Avoid external links, or links to the front page;
      // both have $link['external'] set to 1.
      if (!$link['external'] && !$link['hidden']) {
        _xmlsitemap_menu_link_translate($link);
        if ($link['access'] == 1) {
          $row->loc = $link['href'];
          $row->lid = $link['mlid'];
          $row->priority = min(max(round($link['weight'] / 20 + 0.5, 1), 0), 1);
          if (db_result(db_query("SELECT loc FROM {xmlsitemap} WHERE loc = '%s'", $row->loc)) != $row->loc) {
            drupal_write_record('xmlsitemap', $row);
          }
        }
      }
    }
  }
}

/**
 * Implementation of hook_xmlsitemap_sitemap_settings_alter().
 */
function xmlsitemap_menu_xmlsitemap_sitemap_settings_alter(&$form) {
  $opts = array();
  $result = db_query("SELECT menu_name, title FROM {menu_custom}");
  while ($menu = db_fetch_array($result)) {
    $opts[$menu['menu_name']] = empty($menu['title']) ? $menu['menu_name'] : $menu['title'];
  }
  $default_values = variable_get('xmlsitemap_menu_menus', array());
  // If a menu is not present, remove it from the default settings.
  foreach ($default_values as $id => $value) {
    if (!isset($opts[$id])) {
      unset($default_values[$id]);
    }
  }
  if (!empty($opts)) {
    $form['xmlsitemap_menu'] = array(
      '#type' => 'fieldset',
      '#title' => t('Menu settings'),
      '#description' => t('The settings for the menus to include in the site map.'),
      '#collapsible' => TRUE,
    );
    $form['xmlsitemap_menu']['xmlsitemap_menu_menus'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Menus to include in the site map'),
      '#default_value' => $default_values,
      '#options' => $opts,
      '#checkall' => TRUE,
    );
  }
}

/*****************************************************************************
 * Private functions.
 ****************************************************************************/

/**
 * Check the access to a menu item using the access callback.
 * This is a modified version of _menu_check_access() which check if the anonymous
 * user can access the menu item.
 * @param $item
 *  A menu router or menu link item.
 * @param $map
 *  An array of path arguments (ex: array('node', '5')).
 * @return
 *  $item['access'] becomes TRUE if the item is accessible, FALSE otherwise.
 */
function _xmlsitemap_menu_check_access(&$item, $map) {
  $anonymous = drupal_anonymous_user();
  $callback = empty($item['access_callback']) ? 0 : trim($item['access_callback']);
  if (is_numeric($callback)) {
    $item['access'] = (bool)$callback;
  }
  else {
    $arguments = menu_unserialize($item['access_arguments'], $map);
    if ($callback == 'user_access') {
      $item['access'] = (count($arguments) == 1) ? user_access($arguments[0], $anonymous) : user_access($arguments[0], $arguments[1]);
    }
    else {
      $item['access'] = call_user_func_array($callback, $arguments);
    }
  }
}

/**
 * This function translates the path elements in the map using any to_arg helper
 * function. It does the same task as _link_map_translate().
 * @param map
 *  An array of path arguments (ex: array('node', '5')).
 * @param $to_arg_functions
 *  An array of helper function (ex: array(2 => 'menu_tail_to_arg')).
 */
function _xmlsitemap_menu_link_map_translate(&$map, $to_arg_functions) {
  if ($to_arg_functions) {
    $to_arg_functions = unserialize($to_arg_functions);
    foreach ($to_arg_functions as $index => $function) {
      $arg = $function(!empty($map[$index]) ? $map[$index] : '', $map, $index);
      if (!empty($map[$index]) || isset($arg)) {
        $map[$index] = $arg;
      }
      else {
        unset($map[$index]);
      }
    }
  }
}

/**
 * Prepare a link array to be used. It is a modified version of
 * _menu_link_translate() adopted for the module uses.
 * @param $item
 *  A menu link.
 * @result
 *  FALSE in case of error, TRUE otherwise.
 *  In case of error, the $item['access'] item gets the FALSE value.
 */
function _xmlsitemap_menu_link_translate(&$item) {
  $item['options'] = unserialize($item['options']);
  $map = explode('/', $item['link_path']);
  _xmlsitemap_menu_link_map_translate($map, $item['to_arg_functions']);
  $item['href'] = implode('/', $map);
  if (strpos($item['href'], '%') !== FALSE) {
    $item['access'] = FALSE;
    return FALSE;
  }
  if (!isset($item['access'])) {
    if (!_xmlsitemap_menu_load_objects($item, $map)) {
      $item['access'] = FALSE;
      return FALSE;
    }
    _xmlsitemap_menu_check_access($item, $map);
    if ($item['access']) {
      _xmlsitemap_menu_item_localize($item, $map, TRUE);
    }
  }
  if (!empty($item['options']['alter'])) {
    drupal_alter('translated_menu_link', $item, $map);
  }
  return TRUE;
}
/**
 * Loads objects into the map as defined in the $item['load_functions'].
 * It does the same task as _menu_load_objects().
 * @param $item
 *  A menu router or menu link item.
 * @param $map
 *  An array of path arguments (ex: array('node', '5')).
 * @return
 *  Returns TRUE for success, FALSE if an object cannot be loaded.
 */
function _xmlsitemap_menu_load_objects(&$item, &$map) {
  if ($load_functions = $item['load_functions']) {
    if ($load_functions_unserialized = unserialize($load_functions)) {
      $load_functions = $load_functions_unserialized;
    }
    $path_map = $map;
    foreach ($load_functions as $index => $function) {
      if ($function) {
        $value = isset($path_map[$index]) ? $path_map[$index] : '';
        if (is_array($function)) {
          list($function, $args) = each($function);
          $load_functions[$index] = $function;
          foreach ($args as $i => $arg) {
            if ($arg === '%index') {
              $args[$i] = $index;
            }
            if ($arg === '%map') {
              $args[$i] = &$map;
            }
            if (is_int($arg)) {
              $args[$i] = isset($path_map[$arg]) ? $path_map[$arg] : '';
            }
          }
          array_unshift($args, $value);
          $return = call_user_func_array($function, $args);
        }
        else {
          $return = $function($value);
        }
        if ($return === FALSE) {
          $item['access'] = FALSE;
          $map = FALSE;
          return FALSE;
        }
        $map[$index] = $return;
      }
    }
    $item['load_functions'] = $load_functions;
  }
  return TRUE;
}
/**
 * Localize the router item title using t() or another callback.
 * It does the same task as _menu_item_localize().
 * @param $item
 *  A menu router item or a menu link item.
 * @param $map
 *  The path as an array with objects already replaced. E.g., for path node/123
 *  $map would be array('node', $node) where $node is the node object for node 123.
 * @param $link_translate
 *  TRUE for a menu link item; FALSE for a menu router item.
 */
function _xmlsitemap_menu_item_localize(&$item, $map, $link_translate = FALSE) {
  $callback = $item['title_callback'];
  $item['localized_options'] = $item['options'];
  if (!$link_translate || (!empty($item['title']) && ($item['title'] == $item['link_title']))) {
    if ($callback == 't') {
      if (empty($item['title_arguments'])) {
        $item['title'] = t($item['title']);
      }
      else {
        $item['title'] = t($item['title'], menu_unserialize($item['title_arguments'], $map));
      }
    }
    elseif ($callback) {
      if (empty($item['title_arguments'])) {
        $item['title'] = $callback($item['title']);
      }
      else {
        $item['title'] = call_user_func_array($callback, menu_unserialize($item['title_arguments'], $map));
      }
      if ($callback == 'check_plain') {
        $item['localized_options']['html'] = TRUE;
      }
    }
  }
  elseif ($link_translate) {
    $item['title'] = $item['link_title'];
  }
  if (!empty($item['description'])) {
    $original_description = $item['description'];
    $item['description'] = t($item['description']);
    if ($link_translate && isset($item['options']['attributes']['title']) && $item['options']['attributes']['title'] == $original_description) {
      $item['localized_options']['attributes']['title'] = $item['description'];
    }
  }
}

/**
 * @} End of "addtogroup xmlsitemap".
 */
