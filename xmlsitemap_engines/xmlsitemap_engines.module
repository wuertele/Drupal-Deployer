<?php
// $Id$

/**
 * Implementation of hook_help().
 */
function xmlsitemap_engines_help($path, $arg) {
  $output = '';
  switch ($path) {
    case 'admin/settings/xmlsitemap/engines':
      if (!module_exists('site_verify')) {
        $output .= t('In order to verify site ownership with the search engines listed below, it is highly recommended to download and install the <a href="@site-verify">Site verification module</a>.', array('@site-verify' => 'http://drupal.org/project/site_verify'));
      }
      break;
  }

  return $output;
}

/**
 * Implementation of hook_menu().
 */
function xmlsitemap_engines_menu() {
  $items['admin/settings/xmlsitemap/engines'] = array(
    'title' => 'Search Engines',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xmlsitemap_engines_settings_form'),
    'access arguments' => array('administer xmlsitemap'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'xmlsitemap_engines.admin.inc',
  );
  //$items['admin/settings/xmlsitemap/engines/submit'] = array(
  //  'page callback' => 'xmlsitemap_engines_submit',
  //  'access callback' => 'xmlsitemap_engines_submit_access',
  //  'type' => MENU_CALLBACK,
  //);

  return $items;
}

function xmlsitemap_engines_submit_access() {
  // Cannot submit when site is offline since search engines cannot access the
  // site's content.
  if (variable_get('site_offline', 0)) {
    return FALSE;
  }

  // Allow manual submissions to run.
  //if ($_GET['q'] == 'admin/settings/xmlsitemap/engines/submit' && user_access('administer xmlsitemap')) {
  //  return TRUE;
  //}

  // If sitemap data has not been updated since last submission, skip.
  if (xmlsitemap_engines_var('submit_updated') && xmlsitemap_var('generated_last') < xmlsitemap_engines_var('submit_last')) {
    return FALSE;
  }

  // Check that the minimum submission lifetime has been met.
  if ((REQUEST_TIME - xmlsitemap_engines_var('submit_last')) < xmlsitemap_engines_var('minimum_lifetime')) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Submit the sitemaps to all the specified search engines.
 */
function xmlsitemap_engines_submit_engines() {
  $sitemaps = xmlsitemap_get_sitemaps();
  $engines = xmlsitemap_engines_var('engines');
  foreach ($engines as $engine) {
    $engine_url = xmlsitemap_engines_get_engines($engine, 'url');
    xmlsitemap_engines_submit_sitemaps($engine_url, $sitemaps);
  }

  $custom_urls = xmlsitemap_engines_var('custom_urls');
  $custom_urls = preg_split('/[\r\n]+/', $custom_urls, -1, PREG_SPLIT_NO_EMPTY);
  foreach ($custom_urls as $custom_url) {
    xmlsitemap_engines_submit_sitemaps($custom_url, $sitemaps);
  }

  variable_set('xmlsitemap_engines_submit_last', REQUEST_TIME);
}

/**
 * Submit the sitemaps to a specific URL.
 *
 * @param $url
 *   The URL for sitemap submission.
 * @param $sitemaps
 *   An array of URLs of the sitemaps to submit.
 */
function xmlsitemap_engines_submit_sitemaps($url, $sitemaps = array()) {
  foreach ($sitemaps as $sitemap) {
    $url = xmlsitemap_engines_prepare_url($url, $sitemap);
    $request = drupal_http_request($url);
    watchdog('xmlsitemap', 'Submitted the sitemap to %url and received response @code.', array('%url' => $url, '@code' => $request->code));
  }
}

/**
 * Implementation of hook_cron().
 */
function xmlsitemap_engines_cron() {
  if (xmlsitemap_engines_submit_access()) {
    xmlsitemap_engines_submit_engines();
  }
}

/**
 * Replace valid tokens in the URL with their appropriate values.
 *
 * @param $url
 *   An un-tokenized URL.
 * @return
 *   A tokenized URL.
 */
function xmlsitemap_engines_prepare_url($url, $sitemap) {
  return str_replace('[sitemap]', $sitemap, $url);
}

/**
 * Get a list of supported search engines, or a detail about a specific engine.
 *
 * @param $engine
 *   An optional specific engine to get details about.
 * @param $value
 *   An optional value about an engine to get details about.
 * @return
 *   If $engine and $value are not specified, a two-level array with all the
 *   engines and their details. If $engine is specified but $value is not, an
 *   array with just the details for a specific engine. If $engine and $value
 *   are both specified, just the specific detail for a specific engine.
 */
function xmlsitemap_engines_get_engines($engine = NULL, $value = NULL) {
  static $engines;

  if (!isset($engines)) {
    $engines = array(
      'google' => array(
        'name' => t('Google'),
        'url' => 'http://www.google.com/webmasters/tools/ping?sitemap=[sitemap]',
      ),
      'yahoo' => array(
        'name' => t('Yahoo!'),
        'url' => 'http://search.yahooapis.com/SiteExplorerService/V1/ping?sitemap=[sitemap]',
      ),
      'ask' => array(
        'name' => t('Ask.com'),
        'url' => 'http://submissions.ask.com/ping?sitemap=[sitemap]',
      ),
      'bing' => array(
        'name' => t('Bing (formerly Live Search)'),
        'url' => 'http://www.bing.com/webmaster/ping.aspx?siteMap=[sitemap]',
      ),
      'moreover' => array(
        'name' => t('Moreover'),
        'url' => 'http://api.moreover.com/ping?u=[sitemap]',
      ),
    );

    // Allow other modules to alter or add search engines.
    drupal_alter('xmlsitemap_engines', $engines);
    ksort($engines);
  }

  if (isset($engine) && isset($value)) {
    return isset($engines[$engine][$value]) ? $engines[$engine][$value] : NULL;
  }
  elseif (isset($engine)) {
    return isset($engines[$engine]) ? $engines[$engine] : NULL;
  }
  else {
    return $engines;
  }
}

/**
 * Internal default variables for template_var().
 */
function xmlsitemap_engines_variables() {
  $variables = array(
    'xmlsitemap_engines_engines' => array(),
    'xmlsitemap_engines_custom_urls' => '',
    'xmlsitemap_engines_minimum_lifetime' => 86400,
    'xmlsitemap_engines_submit_last' => 0,
    'xmlsitemap_engines_submit_updated' => TRUE,
  );

  return $variables;
}

/**
 * Internal implementation of variable_get().
 */
function xmlsitemap_engines_var($name, $default = NULL) {
  static $defaults = NULL;
  if (!isset($defaults)) {
    $defaults = xmlsitemap_engines_variables();
  }

  $name = 'xmlsitemap_engines_' . $name;

  // @todo Remove when stable.
  if (!isset($defaults[$name])) {
    trigger_error(t('Default variable for %variable not found.', array('%variable' => $name)));
  }

  return variable_get($name, isset($default) || !isset($defaults[$name]) ? $default : $defaults[$name]);
}
