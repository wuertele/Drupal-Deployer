<?php
// $Id$

/**
 * @file
 * Provide server side mime type detection.
 *
 * @author Darrel O'Pry, http://www.drupal.org/user/22202
 * @copyright Copyright(c) 2007, Darrel O'Pry
 */


function mimedetect_menu() {
  $items = array();

  // The admin settings form.
  $items['admin/settings/mimedetect'] = array(
    'title' => 'Mime type detection',
    'description' => 'Control how the mime type of uploaded files will be determined.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mimedetect_settings'),
    'access arguments' => array('administer site configuration'),
  );

  return $items;
}


function mimedetect_settings() {
  $form = array();
  $form['mimedetect_enable_file_binary'] = array(
    '#type' => 'checkbox',
    '#title' => t("Use UNIX 'file' command to detect mime type?"),
    '#description' => t("The UNIX 'file' command will be used for mime detection only if the PHP Fileinfo extension is not installed or fails to load."),
    '#default_value' => variable_get('mimedetect_enable_file_binary', FALSE),
  );
  $form['mimedetect_file_binary'] = array(
    '#type' => 'textfield',
    '#title' => t("Path to the 'file' command"),
    '#description' => t("The path to the executable 'file' binary."),
    '#default_value' => variable_get('mimedetect_file_binary','/usr/bin/file'),
  );
  return system_settings_form($form);
}

function mimedetect_settings_validate($form_id, &$form_state) {
  // Test file binary settings.
  if ($form_state['values']['mimedetect_enable_file_binary']) {
    if (empty($form_state['values']['mimedetect_file_binary'])) {
      form_set_error('mimedetect_file_binary', t("You must specify the path to the 'file' binary if it is enabled."));
    }
    if (!is_executable($form_state['values']['mimedetect_file_binary'])) {
      if (!file_exists($form_state['values']['mimedetect_file_binary'])) {
        form_set_error('mimedetect_file_binary', t("The path %path does not exist or is not readable by your webserver.", array('%path' => $form_state['values']['mimedetect_file_binary'])));
      }
      else {
        form_set_error('mimedetect_file_binary', t("%path is not executable by your webserver.", array('%path' => $form_state['values']['mimedetect_file_binary'])));
      }
    }
  }
}

/**
 * Detect File Mime Type.
 *
 * @param $file A standard Drupal file object. The filepath property is used to
 *   locate the file and if the mime detection fails, the mimetype property is
 *   returned.
 * @return String containing the file's MIME type.
 */
function mimedetect_mime($file) {
  $file = (object)$file;

  // An additional array of mimetypes not included in file_get_mimetype().
  static $additional_mimes = array(
    // Audio types
    'rmi' => 'audio/midi',
    'aidff' => 'audio/x-aiff',
    // Image types
    'cod' => 'image/cis-cod',
    'jfif' => 'image/pipeg',
    'cmx' => 'image/x-cmx',
    // Video types
    'mpa' => 'video/mpeg',
    'mpv2' => 'video/mpeg',
    'asr' => 'video/x-ms-asf',
  );

  $mime = FALSE;

  // Try to use the fileinfo extension first.
  if (extension_loaded('fileinfo')) {
    static $finfo = FALSE;
    if ($finfo || $finfo = @finfo_open(FILEINFO_MIME, drupal_get_path('module', 'mimedetect') .'/magic')) {
      $mime = finfo_file($finfo, realpath($file->filepath));
    }
  }

  // Try the 'file' binary.
  if (!$mime && variable_get('mimedetect_enable_file_binary', FALSE)
    && ($filebin = variable_get('mimedetect_file_binary', '/usr/bin/file'))
    && is_executable($filebin))
  {
    // On OSX the -i switch is -I, so if we use the long flags everyone is
    // happy. I checked back to version 3.41 and it still supports the long
    // names but if you run into problems you can use " -bi ".
    $command = $filebin .' --brief --mime '. escapeshellarg($file->filepath);
    $mime = trim(exec($command, $out));
    // with text we often get charset like 'text/plain; charset=us-ascii'
    $mime = split(';', $mime);
    $mime = trim($mime[0]);
  }

  // ASF derived media formats are hard to detect with magic. They're typically
  // all reported as video/x-ms-asf or application/octet-stream. These aren't
  // really informative about the media type, so we attempt to figure it out by
  // extension. I expect OGG to present similar difficulties in determining how
  // it should be played.
  if (!$mime || $mime == 'application/octet-stream') {
    // Try core's mime mapping first...
    $mime = file_get_mimetype($file->filename);
    // ...and if that doesn't turn up anything try our additional mappings.
    if ($mime == 'application/octet-stream') {
      $mime = file_get_mimetype($file->filename, $additional_mimes);
    }
  }

  return $mime;
}
