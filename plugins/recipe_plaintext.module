<?php
// $Id$

/**
 * @file
 * recipe_plaintext.module - Support for the plaintext format input and output.
 *
 * Format Spec
 *
 *             Line1: TITLE
 *                    BLANK LINE
 * Ingredient Lines : <quantity> <unit> <ingredient>
 *                    ...
 *                    BLANK LINE
 * Instruction Lines: Freeform Instructions, blank lines ok from here on.
 */


/**
 * Implementation of hook_recipeio($type).
 */
function recipe_plaintext_recipeio($type) {
  $supported = array(
    'import_single' => array(
      'format_name' => t('Plain Text'),
      'callback' => 'recipe_plaintext_import',
      'format_help' => ''
    ),
    'export_single' => array(
      'format_name' => t('Plain Text'),
      'callback' => 'recipe_plaintext_export',
      'format_help' => t('Export to a plain text format.')
    )
  );
  return array('plaintext'=>$supported[$type]);
}


/**
 * Parsing instance for plain text recipes
 */
function recipe_plaintext_import($text) {
  // region constants
  define('TITLE', 0);
  define('INGREDIENTS', 1);
  define('DIRECTIONS', 2);

  $recipe = array();

  $region = TITLE;
  foreach (split("\n", $text) as $line) {
    $line = trim($line);
    if ( $region < DIRECTIONS && $line == '' ) {
      $region++;
      continue;
    }
    if ( $region == TITLE ) {
      $recipe['title'] = $line;
    }
    else if ( $region == INGREDIENTS ) {
      // 1 cup flour
      if ( preg_match('/^([0-9\-\.\/]+) +([A-Za-z\.]+) +(.*)/', $line, $matches)  ) {
        $i = array();
        $i['quantity'] = $matches[1];
        $i['unit_name'] = $matches[2];
        $i['ingredient_name'] = $matches[3];

        // FALSE if no-match
        $i['unit_obj'] = recipe_unit_fuzzymatch($i['unit_name']);

        // FALSE if no-match
        $i['ingred_obj'] = recipe_ingredient_match($i['ingredient_name']);

        $recipe['ingredients'][] = $i;
      }

      // 1 apple
      elseif ( preg_match('/^([0-9\-\.\/]+) +(.*)/', $line, $matches)  ) {
        $i = array();
        $i['quantity'] = $matches[1];
        $i['unit_name'] = 'Unit';
        $i['ingredient_name'] = $matches[2];

        // FALSE if no-match
        $i['unit_obj'] = recipe_unit_fuzzymatch($i['unit_name']);

        // FALSE if no-match
        $i['ingred_obj'] = recipe_ingredient_match($i['ingredient_name']);

        $recipe['ingredients'][] = $i;
      }

      else {
        $i = array();
        $i['quantity'] = 0;
        $i['unit_name'] = 'Unit';
        $i['ingredient_name'] = "failed: " . $line;
        $i['unit_obj'] = FALSE;
        $i['ingred_obj'] = FALSE;
        $recipe['ingredients'][] = $i;
      }
    }
    else if ( $region == DIRECTIONS ) {
      $recipe['instructions'] .= $line ."\n";
    }
  }
  return $recipe;
}


function recipe_plaintext_export($nid = NULL) {
  if ( $nid === NULL ) {
    drupal_set_message(t('Recipe not found.'));
    drupal_not_found();
  }

  $node = node_load(array('nid' => $nid, 'type' => 'recipe'));

  $output = $node->title;
  $output .= "\n\n";
  foreach ( $node->ingredients as $key => $i ) {
    $output .= $i->quantity .' '. $i->abbreviation .' '. $i->name ."\n";
  }
  $output .= "\n";
  $tmp = "Instructions:\n". $node->instructions ."\n\nDescription:\n". $node->body ."\n\nNotes:\n". $node->notes;
  $tmp = str_replace('<p>', '', $tmp);
  $output .= $tmp;

  drupal_set_header('Content-type: text');
  return $output;
}